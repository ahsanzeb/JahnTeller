(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* Real Ylm can be written as superpositions of complex Ylm's with \[PlusMinus]m; 
 A[m] is coeff of Y_l^{m}; B[m] is coeff of Y_l^{-m};*)
A[m_]:=If[m<0,I/Sqrt[2],If[m==0,1,(-1)^m/Sqrt[2]]];
B[m_]:=If[m<0,-I(-1)^m/Sqrt[2],If[m==0,0,1/Sqrt[2]]];
YlmReal[l_,m_,\[Theta]_,\[Phi]_]:=A[m]SphericalHarmonicY[l,m,\[Theta],\[Phi]] + B[m]SphericalHarmonicY[l,-m,\[Theta],\[Phi]];


(* ::Input::Initialization:: *)
(* xAr=
(\[NoBreak]\[Sigma]	\[Sigma]	\[Tau]
\[Mu]	-\[Mu]	\[Tau]
\[Sigma]	\[Sigma]	-\[Tau]
\[Mu]	-\[Mu]	-\[Tau]
-\[Sigma]	-\[Sigma]	\[Tau]
-\[Mu]	\[Mu]	\[Tau]
-\[Sigma]	-\[Sigma]	-\[Tau]
-\[Mu]	\[Mu]	-\[Tau]

\[NoBreak])
*)


(* ::Input::Initialization:: *)
(*
(* comparison with beast structure *)
avecs=Import[NotebookDirectory[]<>"check-beast-axes/avecs.dat"];
avecs0=ArrayReshape[avecs,{3,11,9}];
Manipulate[
Show[ListPlot[1/7.0 avecs0[[it]]//Transpose,DataRange\[Rule]{0,20 Pi/180}],
Plot[{Cos[\[Phi]],-Cos[\[Theta]] Cos[\[Phi]],0,Cos[\[Phi]],Cos[\[Theta]] Cos[\[Phi]],0,0,0,2 Cos[\[Theta]]}/.If[it\[Equal]2, {\[Theta]\[Rule] x,\[Phi]\[Rule] 0},If[it\[Equal]1,{\[Theta]\[Rule] 0,\[Phi]\[Rule] x},{\[Theta]\[Rule] x,\[Phi]\[Rule] x}]],{x,0,20 Pi/180}]
]
,{it,1,3,1}]*)


(* ::Input::Initialization:: *)




(* ::Input::Initialization:: *)
(*symb = {x,y,z,u,v,w,\[Sigma],\[Mu],\[Tau]} *)
rules:={u-> Cos[\[Alpha]/2]^2 Cos[\[Beta]],v-> Cos[\[Beta]] Sin[\[Alpha]/2]^2,w-> Cos[\[Alpha]],\[Sigma]->Cos[\[Beta]]/2,\[Tau]-> Cos[\[Alpha]]/2,\[Mu]-> -(1/2) Cos[\[Alpha]] Cos[\[Beta]]};


(* ::Input::Initialization:: *)
getVmsIndividualQs[\[Alpha]_,\[Beta]_,r_,\[Theta]_,\[Phi]_,symb_]:=Module[{avecr,xb,xbr,p,xr,r1,\[Theta]1,xi,pi,V,Vtot,xx,pxyz,xuvw,pb,xa,xar,pa,dAsx,
x,y,z,u,v,w,\[Sigma],\[Mu],\[Tau],Vtota,Vtotb},
{x,y,z,u,v,w,\[Sigma],\[Mu],\[Tau]}=symb;


getPotential[coor_,xr_]:=Module[{Va,na},
na=Dimensions[coor][[2]];
Do[
xi=coor[[;;,i]];
r1=xr-xi;
Va[i]=1/Norm[r1];
,{i,1,na}];
Sum[Va[i],{i,1,na}]/.Abs[j_]-> j(*/.Conjugate[j_]\[Rule] j*)
];

(* \[Alpha],\[Beta] rotation angles
out={avecr,B1xBs,B1xBsr,B1dBs,As0,As,dAs(*,oct1O*)} *)
{avecr,xb,xbr,pb,xa,xar,pa}=getDeviations[\[Alpha],\[Beta]];

xuvw=xbr;
xuvw[[;;,1]]={x,y,0};
xuvw[[;;,2]]={y,x,0};
xuvw[[;;,3]]={0,0,z};
xuvw[[;;,4]]=-{x,y,0};
xuvw[[;;,5]]=-{y,x,0};
xuvw[[;;,6]]=-{0,0,z};
xuvw=xuvw/.{x-> u,y-> v,z-> w};
(*
symbols = {u\[Rule] Cos[\[Alpha]/2]^2 Cos[\[Beta]],v\[Rule] Cos[\[Beta]] Sin[\[Alpha]/2]^2,w\[Rule] Cos[\[Alpha]],\[Sigma]\[Rule]Cos[\[Beta]]/2,\[Tau]\[Rule] Cos[\[Alpha]]/2,\[Mu]\[Rule] -(1/2) Cos[\[Alpha]] Cos[\[Beta]]}
*)
xr=CoordinateTransform["Spherical"->"Cartesian",{r,\[Theta],\[Phi]}];

xx={{\[Sigma],\[Mu],\[Sigma],\[Mu],-\[Sigma],-\[Mu],-\[Sigma],-\[Mu]},{\[Sigma],-\[Mu],\[Sigma],-\[Mu],-\[Sigma],\[Mu],-\[Sigma],\[Mu]},{\[Tau],\[Tau],-\[Tau],-\[Tau],\[Tau],\[Tau],-\[Tau],-\[Tau]}};

Vtotb=getPotential[xuvw,xr];
Vtota=getPotential[xx,xr];



{Vtota,Vtotb}
]


(* ::Input::Initialization:: *)
(*{VtotaQ,VtotbQ}=getVmsIndividualQs[\[Alpha],\[Beta],r,\[Theta],\[Phi],{x,y,z,u,v,w,\[Sigma],\[Mu],\[Tau]}];*)


(* ::Input::Initialization:: *)
getCoeff[Vtot_]:=Module[{coeff,Vl,Ylms,Vlms,VYlms,Eqs,sol,lmx,xnm},

lmx=4;
coeff={};
Do[
Print["Finding coefficients of Ylm's: l = ",l];
Vl=SeriesCoefficient[Vtot,{r,0,l}]//ExpToTrig//TrigExpand;

Ylms=Table[YlmReal[l,m,\[Theta],\[Phi]],{m,-l,l}];
Vlms=Table[Vlm[l,m],{m,-l,l}];
(*Vlm[l,#]&/@Range[-l,l];*)
VYlms=(Ylms.Vlms)//ExpToTrig//TrigExpand;
(* //ExpToTrig//TrigExpand required to make Sin and Cos as functions of only simple theta and phi: Cos[\[Theta]],Cos[\[Phi]],Sin[\[Theta]],Sin[\[Phi]] *)

Eqs={};
Do[
xnm=SeriesCoefficient[Vl/.{Sin[\[Theta]]-> Sqrt[1-Cos[\[Theta]]^2],Sin[\[Phi]]-> Sqrt[1-Cos[\[Phi]]^2]},{Cos[\[Theta]],0,n},{Cos[\[Phi]],0,m}]==SeriesCoefficient[VYlms
/.{Sin[\[Theta]]-> Sqrt[1-Cos[\[Theta]]^2],Sin[\[Phi]]-> Sqrt[1-Cos[\[Phi]]^2]},{Cos[\[Theta]],0,n},{Cos[\[Phi]],0,m}];
AppendTo[Eqs,xnm];
(*Print[" Eq = ",xnm];*)
,{n,0,lmx},{m,0,lmx}];

(*Do[
Eqs[[i]]//Print,
{i,1,Length[Eqs]}];
Vlms//Print;*)

sol=Solve[Eqs,Vlms,Reals];
sol//ArrayReshape[#,{2l+1,1}]&//MatrixForm//Print;
AppendTo[coeff,Vlms/.sol];
,{l,1,lmx,1}];

coeff
];



(* ::Input::Initialization:: *)
getVmsIndividualQsSL[\[Alpha]_,\[Beta]_,r_,\[Theta]_,\[Phi]_,symb_]:=Module[{avecr,xb,xbr,p,xr,r1,\[Theta]1,xi,pi,V,Vtot,xx,pxyz,xuvw,pb,xa,xar,pa,dAsx,
x,y,z,u,v,w,\[Sigma],\[Mu],\[Tau],Vtota,Vtotb,Vtota2,Vtotb2},
{x,y,z,u,v,w,\[Sigma],\[Mu],\[Tau]}=symb;


getPotential[coor_,xr_]:=Module[{Va,na},
na=Dimensions[coor][[2]];
Do[
xi=coor[[;;,i]];
r1=xr-xi;
Va[i]=1/Norm[r1];
,{i,1,na}];
Sum[Va[i],{i,1,na}]/.Abs[j_]-> j(*/.Conjugate[j_]\[Rule] j*)
];

(* \[Alpha],\[Beta] rotation angles
out={avecr,B1xBs,B1xBsr,B1dBs,As0,As,dAs(*,oct1O*)} *)
{avecr,xb,xbr,pb,xa,xar,pa}=getDeviations[\[Alpha],\[Beta]];

xuvw=xbr;
xuvw[[;;,1]]={x,y,0};
xuvw[[;;,2]]={y,x,0};
xuvw[[;;,3]]={0,0,z};
xuvw[[;;,4]]=-{x,y,0};
xuvw[[;;,5]]=-{y,x,0};
xuvw[[;;,6]]=-{0,0,z};
xuvw=xuvw/.{x-> u,y-> v,z-> w};
(*
symbols = {u\[Rule] Cos[\[Alpha]/2]^2 Cos[\[Beta]],v\[Rule] Cos[\[Beta]] Sin[\[Alpha]/2]^2,w\[Rule] Cos[\[Alpha]],\[Sigma]\[Rule]Cos[\[Beta]]/2,\[Tau]\[Rule] Cos[\[Alpha]]/2,\[Mu]\[Rule] -(1/2) Cos[\[Alpha]] Cos[\[Beta]]}
*)
xr=CoordinateTransform["Spherical"->"Cartesian",{r,\[Theta],\[Phi]}];

xx={{\[Sigma],\[Mu],\[Sigma],\[Mu],-\[Sigma],-\[Mu],-\[Sigma],-\[Mu]},{\[Sigma],-\[Mu],\[Sigma],-\[Mu],-\[Sigma],\[Mu],-\[Sigma],\[Mu]},{\[Tau],\[Tau],-\[Tau],-\[Tau],\[Tau],\[Tau],-\[Tau],-\[Tau]}};

(* same layer B atoms*)
Vtotb=getPotential[xuvw[[;;,{1,2,4,5}]],xr];
(* upper layer A atoms*)
Vtota=getPotential[xx[[;;,{1,2,5,6}]],xr];

(* top and bottom B atoms*)
Vtotb2=getPotential[xuvw[[;;,{3,6}]],xr];
(* lower layer A atoms*)
Vtota2=getPotential[xx[[;;,{3,4,7,8}]],xr];

{Vtota2,Vtota,Vtotb,Vtotb2}
]
